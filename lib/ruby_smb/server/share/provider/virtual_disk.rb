require 'ruby_smb/server/share/provider/disk'
require 'ruby_smb/server/share/provider/virtual_disk/virtual_file'
require 'ruby_smb/server/share/provider/virtual_disk/virtual_pathname'
require 'ruby_smb/server/share/provider/virtual_disk/virtual_stat'

module RubySMB
  class Server
    module Share
      module Provider
        # This is a share provider that exposes a virtual file system whose entries do not exist on disk.
        # @since 3.1.1
        class VirtualDisk < Disk
          # @param [String] name The name of this share.
          def initialize(name)
            @vfs = {}
            super(name, add(VirtualPathname.new(self, File::SEPARATOR)))
          end

          # Add a dynamic file to the virtual file system. A dynamic file is one whose contents are generated by the
          # specified block. The contents must be of a fixed size and will either be truncated or padded to that size.
          #
          # @param [String] path The path of the file to add, relative to the share root.
          # @param [Integer] content_size The size in bytes of the file contents.
          # @param [File::Stat] stat An explicit stat object describing the file.
          # @param [String] pad The character to use for padding the contents when necessary.
          # @yield The content generation routine.
          # @yieldreturn [String] The generated file content.
          def add_dynamic_file(path, content_size, stat: nil, pad: "\x00", &block)
            raise ArgumentError.new('a block must be specified for dynamic files') unless block_given?
            path = VirtualPathname.cleanpath(path)
            path = File::SEPARATOR + path unless path.start_with?(File::SEPARATOR)
            raise ArgumentError.new('must be a file') if stat && !stat.file?

            vf = VirtualDynamicFile.new(self, path, content_size, stat: stat, pad: pad)
            vf.generate_content(&block)
            add(vf)
          end

          # Add a mapped file to the virtual file system. A mapped file is one who is backed by an entry on
          # disk. The path need not be present, but if it does exist, it must be a file.
          #
          # @param [String] path The path of the file to add, relative to the share root.
          # @param [String, Pathname] mapped_path The path on the local file system to map into the virtual file system.
          def add_mapped_file(path, mapped_path)
            path = VirtualPathname.cleanpath(path)
            path = File::SEPARATOR + path unless path.start_with?(File::SEPARATOR)

            vf = VirtualMappedFile.new(self, path, mapped_path)
            add(vf)
          end

          # Add a static file to the virtual file system. A static file is one whose contents are known at creation time
          # and do not change.
          #
          # @param [String] path The path of the file to add, relative to the share root.
          # @param [String, #read] content The static content to add.
          # @param [File::Stat] stat An explicit stat object describing the file.
          def add_static_file(path, content, stat: nil)
            path = VirtualPathname.cleanpath(path)
            path = File::SEPARATOR + path unless path.start_with?(File::SEPARATOR)
            raise ArgumentError.new('must be a file') if stat && !stat.file?

            content = content.read if content.respond_to?(:read)
            vf = VirtualStaticFile.new(self, path, content, stat: stat)
            add(vf)
          end

          # Add a file object to the virtual file system. This will read the file and create a new static file from the
          # contents. The file's #stat object will be copied over.
          #
          # @param [String] path The path of the file to add, relative to the share root.
          # @param [#stat] file_obj The file object to take the stat object and content from.
          def add_static_fileobj(path, file_obj)
            add_static_file(path, file_obj, stat: file_obj.stat)
          end

          private

          def add(virtual_pathname)
            raise ArgumentError.new('paths must be absolute') unless virtual_pathname.absolute?

            path = virtual_pathname.to_s
            raise ArgumentError.new('paths must be normalized') unless VirtualPathname.cleanpath(path) == path

            path_parts = path.split(VirtualPathname::SEPARATOR)
            2.upto(path_parts.length - 1) do |idx|
              ancestor = path_parts[0...idx].join(path[VirtualPathname::SEPARATOR])
              next if @vfs[ancestor]&.directory?

              @vfs[ancestor] = VirtualPathname.new(self, ancestor, stat: VirtualStat.new(directory?: true))
            end

            @vfs[path] = virtual_pathname
          end

          def method_missing(symbol, *args)
            if %i[ [] each each_key each_value ].include?(symbol)
              return @vfs.send(symbol, *args)
            end

            raise NoMethodError, "undefined method `#{symbol}' for #{self.class}"
          end
        end
      end
    end
  end
end
